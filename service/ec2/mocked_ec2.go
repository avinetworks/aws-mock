/*
Copyright 2018 The Avi Networks.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
package ec2

import (
	"strings"

	randomdata "github.com/Pallinder/go-randomdata"
	awssdk "github.com/aws/aws-sdk-go/aws"
	ec2 "github.com/aws/aws-sdk-go/service/ec2"
	"github.com/aws/aws-sdk-go/service/ec2/ec2iface"

	"errors"
	"net"

	"github.com/golang/protobuf/proto"
	mock "github.com/stretchr/testify/mock"

	"github.com/google/uuid"
)

const RUNNING int64 = 16
const STOP int64 = 80

// EC2API is an autogenerated mock type for the EC2API type
type EC2API struct {
	mock.Mock
	vpcs                     map[string]*ec2.Vpc
	vpcassocaiatedsubnet     map[string][]*ec2.Subnet         // vpc name will be key
	networkinterfaces        map[string]*ec2.NetworkInterface // interfaceid will be the name
	assignedIpOnSubnet       map[string][]string              // key subnet id
	subnets                  map[string]*ec2.Subnet           // key subnet id
	assignedMacAddress       []string                         //assigned mac address
	assignedelasticIps       map[string]string                // key is allocation id
	assignedsecurityGroups   map[string]*ec2.SecurityGroup    // key is security group id
	createdEc2instances      []*ec2.Instance
	defaultSecurityGroupID   string
	defaultSubnetId          string
	routeTable               map[string]*ec2.RouteTable
	recorder                 *Recorder
	defaultSecurityGroupName string
}

var AVI_STANDARD_ELASTIC_ALLOCATION_DOMAIN string = "aws"

var _ ec2iface.EC2API = &EC2API{}

//supported filters
var supportedsubnetfilter []string = []string{"vpc-id", "availabilityZone", "cidrBlock"}

var defaultServiceEngineInstanceName = "service-engine"
var defaultAvailabilityZone = "us-east-1"
var defaultVpcID = "avi-seeding-vpc"
var defaultCidrBlock = "10.0.0.0/16"
var defaultVpcState = "available"
var defaultSubnetCidr = "10.0.0.0/24"

func New() *EC2API {
	// aws allocate default security group to every instances
	securityGroupId := uuid.New()

	securityGroupIdStr := "sg-" + securityGroupId.String()
	securityGroupName := "sg-default"
	defaultSecurityGroup := &ec2.SecurityGroup{
		GroupId:     &securityGroupIdStr,
		GroupName:   &securityGroupName,
		VpcId:       &defaultVpcID,
		Description: proto.String("default security group"),
	}
	defaultSecurityGroups := map[string]*ec2.SecurityGroup{}
	defaultSecurityGroups[securityGroupIdStr] = defaultSecurityGroup
	recorder := &Recorder{}
	recorder.init()
	return &EC2API{
		vpcs:                     make(map[string]*ec2.Vpc, 0),
		vpcassocaiatedsubnet:     make(map[string][]*ec2.Subnet, 0),
		networkinterfaces:        make(map[string]*ec2.NetworkInterface, 0),
		assignedIpOnSubnet:       make(map[string][]string, 0),
		subnets:                  make(map[string]*ec2.Subnet, 0),
		assignedMacAddress:       make([]string, 0),
		assignedelasticIps:       make(map[string]string, 0),
		assignedsecurityGroups:   defaultSecurityGroups,
		createdEc2instances:      make([]*ec2.Instance, 0),
		defaultSecurityGroupID:   securityGroupIdStr,
		recorder:                 recorder,
		routeTable:               make(map[string]*ec2.RouteTable, 0),
		defaultSecurityGroupName: securityGroupName,
	}
}

func (_m *EC2API) EXPECT() *Recorder {
	return _m.recorder
}

func (_m *EC2API) AppendInstance(instance *ec2.Instance) {
	instance.State = &ec2.InstanceState{
		Code: proto.Int64(RUNNING),
		Name: proto.String("running"),
	}
	_m.createdEc2instances = append(_m.createdEc2instances, instance)
}

func (_m *EC2API) AppendVpcs(vpc *ec2.Vpc) {
	_m.vpcs[*vpc.VpcId] = vpc
}

func (_m *EC2API) GetDefaultSecurityGroupID() string {
	return _m.defaultSecurityGroupID
}

func (_m *EC2API) InitialSeeding() {

	// seeding default vpc
	_m.AppendVpcs(&ec2.Vpc{
		VpcId:     &defaultVpcID,
		CidrBlock: &defaultCidrBlock,
		State:     &defaultVpcState,
	})

	// default subnet in vpc
	createSubnetOutput, _ := _m.CreateSubnet(
		&ec2.CreateSubnetInput{
			CidrBlock:        &defaultSubnetCidr,
			VpcId:            &defaultVpcID,
			AvailabilityZone: &defaultAvailabilityZone,
		},
	)
	_m.defaultSubnetId = *createSubnetOutput.Subnet.SubnetId
	networkInterface, _ := _m.CreateNetworkInterface(&ec2.CreateNetworkInterfaceInput{
		Description: awssdk.String("se nic"),
		SubnetId:    awssdk.String(_m.GetDefaultSubnetID()),
	})

	//populating route table, we'll associate one public route as well for
	// avi networks internal testing
	routeTableID := "avi-route-table-" + uuid.New().String()
	routeTableAssociationID := "avi-route-table-association-" + uuid.New().String()
	_m.routeTable[routeTableID] = &ec2.RouteTable{
		VpcId:        &defaultVpcID,
		RouteTableId: &routeTableID,
		Associations: []*ec2.RouteTableAssociation{
			&ec2.RouteTableAssociation{
				RouteTableAssociationId: &routeTableAssociationID,
				Main:         proto.Bool(true),
				RouteTableId: &routeTableID,
			},
		},
		Routes: []*ec2.Route{
			&ec2.Route{
				GatewayId:            proto.String("local"),
				DestinationCidrBlock: &defaultCidrBlock,
				State:                proto.String("active"),
				Origin:               proto.String("Create Route Table"),
			},
		},
	}

	routeTableID = "avi-route-table-" + uuid.New().String()
	routeTableAssociationID = "avi-route-table-association-" + uuid.New().String()
	_m.routeTable[routeTableID] = &ec2.RouteTable{
		VpcId:        &defaultVpcID,
		RouteTableId: &routeTableID,
		Associations: []*ec2.RouteTableAssociation{
			&ec2.RouteTableAssociation{
				RouteTableAssociationId: &routeTableAssociationID,
				Main:         proto.Bool(false),
				RouteTableId: &routeTableID,
				SubnetId:     &_m.defaultSubnetId,
			},
		},
		PropagatingVgws: []*ec2.PropagatingVgw{
			&ec2.PropagatingVgw{
				GatewayId: proto.String("igw-avi-internet-gateway"),
			},
		},
		Routes: []*ec2.Route{
			&ec2.Route{
				GatewayId:            proto.String("igw-avi-internet-gateway"),
				DestinationCidrBlock: proto.String("0.0.0.0/0"),
				State:                proto.String("active"),
				Origin:               proto.String("Create Route Table"),
			},
		},
	}

	// service engine
	_m.AppendInstance(&ec2.Instance{
		InstanceId: &defaultServiceEngineInstanceName,
		VpcId:      &defaultVpcID,
		NetworkInterfaces: []*ec2.InstanceNetworkInterface{
			&ec2.InstanceNetworkInterface{
				VpcId:              &defaultVpcID,
				NetworkInterfaceId: networkInterface.NetworkInterface.NetworkInterfaceId,
				MacAddress:         networkInterface.NetworkInterface.MacAddress,
				PrivateIpAddress:   networkInterface.NetworkInterface.PrivateIpAddress,
				SubnetId:           networkInterface.NetworkInterface.SubnetId,
			},
		},
		Placement: &ec2.Placement{
			AvailabilityZone: &defaultAvailabilityZone,
		},
		Tags: []*ec2.Tag{
			&ec2.Tag{
				Key:   proto.String("name"),
				Value: &defaultServiceEngineInstanceName,
			},
		},
		SecurityGroups: []*ec2.GroupIdentifier{
			&ec2.GroupIdentifier{
				GroupId:   &_m.defaultSecurityGroupID,
				GroupName: &_m.defaultSecurityGroupName,
			},
		},
	})
}

func (_m *EC2API) GetDefaultSubnetID() string {
	return _m.defaultSubnetId
}

func (_m *EC2API) GetDefaultServiceEngine() *ec2.Instance {
	for _, instance := range _m.createdEc2instances {
		if *instance.InstanceId == defaultServiceEngineInstanceName {
			return instance
		}
	}
	panic("no initial seeding")
}

func (_ *EC2API) GetDefaultAvailabiltyZone() string {
	return defaultAvailabilityZone
}

func (_m *EC2API) GetDefaultVPCID() string {
	return defaultVpcID
}

func (_m *EC2API) GetDefaultVPCCIDRBlock() string {
	return defaultCidrBlock
}

func (_m *EC2API) GetDefaultSubnetCidr() string {
	return defaultSubnetCidr
}

func (_m *EC2API) CreateInstace(name, subnetId, vpcId string) *ec2.Instance {
	// It is not part of EC2 api
	networkInterface, _ := _m.CreateNetworkInterface(&ec2.CreateNetworkInterfaceInput{
		Description: awssdk.String("interface for " + name),
		SubnetId:    awssdk.String(subnetId),
	})
	instanceid := name + "-" + uuid.New().String()
	instance := &ec2.Instance{
		InstanceId: &instanceid,
		VpcId:      &vpcId,
		NetworkInterfaces: []*ec2.InstanceNetworkInterface{
			&ec2.InstanceNetworkInterface{
				VpcId:              &vpcId,
				NetworkInterfaceId: networkInterface.NetworkInterface.NetworkInterfaceId,
				MacAddress:         networkInterface.NetworkInterface.MacAddress,
				PrivateIpAddress:   networkInterface.NetworkInterface.PrivateIpAddress,
				SubnetId:           networkInterface.NetworkInterface.SubnetId,
			},
		},
		Placement: &ec2.Placement{
			AvailabilityZone: &defaultAvailabilityZone,
		},
		Tags: []*ec2.Tag{
			&ec2.Tag{
				Key:   proto.String("name"),
				Value: &instanceid,
			},
		},
		SecurityGroups: []*ec2.GroupIdentifier{
			&ec2.GroupIdentifier{
				GroupId:   &_m.defaultSecurityGroupID,
				GroupName: &_m.defaultSecurityGroupName,
			},
		},
	}
	_m.AppendInstance(instance)
	return instance
}

// DescribeVpcs provides a mock function with given fields: _a0
func (_m *EC2API) DescribeVpcs(req *ec2.DescribeVpcsInput) (*ec2.DescribeVpcsOutput, error) {
	output := &ec2.DescribeVpcsOutput{}
	if err := _m.recorder.CheckError("DescribeVpcs"); err != nil {

		return output, err
	}
	_m.recorder.Record("DescribeVpcs")
	returns, exist := _m.recorder.giveRecordedOutput("DescribeVpcs", req)
	if exist {

		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.DescribeVpcsOutput), assertedErr
	}
	for _, reqvpcid := range req.VpcIds {
		for _, vpc := range _m.vpcs {
			if reqvpcid == vpc.VpcId {
				output.Vpcs = append(output.Vpcs, vpc)
			}
		}
	}
	return output, nil
}

// CreateSubnet provides a mock function with given fields: _a0
func (_m *EC2API) CreateSubnet(_a0 *ec2.CreateSubnetInput) (output *ec2.CreateSubnetOutput, err error) {
	output = &ec2.CreateSubnetOutput{}
	if err := _m.recorder.CheckError("CreateSubnet"); err != nil {
		return output, err
	}
	_m.recorder.Record("CreateSubnet")
	returns, exist := _m.recorder.giveRecordedOutput("CreateSubnet", _a0)
	if exist {

		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.CreateSubnetOutput), assertedErr
	}
	_, _, err = net.ParseCIDR(*_a0.CidrBlock)
	if err != nil {
		return nil, err
	}
	_, ok := _m.vpcs[*_a0.VpcId]
	if !ok {
		return nil, errors.New("vpc not exist")
	}
	subnetId := "subnet-" + rangeIn(1000, 9999)
	ipv6block := []*ec2.SubnetIpv6CidrBlockAssociation{}
	if _a0.Ipv6CidrBlock != nil {
		ipv6associationid := "subnet-cidr-assoc-" + rangeIn(1000, 9999)
		defaultState := "ASSOCIATED"
		ipv6block = append(ipv6block, &ec2.SubnetIpv6CidrBlockAssociation{
			Ipv6CidrBlock: _a0.Ipv6CidrBlock,
			AssociationId: &ipv6associationid,
			Ipv6CidrBlockState: &ec2.SubnetCidrBlockState{
				State: &defaultState,
			},
		})
	}
	subnet := &ec2.Subnet{
		CidrBlock:                   _a0.CidrBlock,
		AvailabilityZone:            _a0.AvailabilityZone,
		VpcId:                       _a0.VpcId,
		SubnetId:                    &subnetId,
		Ipv6CidrBlockAssociationSet: ipv6block,
	}

	_m.vpcassocaiatedsubnet[*_a0.VpcId] = append(_m.vpcassocaiatedsubnet[*_a0.VpcId], subnet)
	_m.subnets[subnetId] = subnet
	output = &ec2.CreateSubnetOutput{
		Subnet: subnet,
	}
	return
}

// DescribeSubnets provides a mock function with given fields: _a0
func (_m *EC2API) DescribeSubnets(_a0 *ec2.DescribeSubnetsInput) (output *ec2.DescribeSubnetsOutput, err error) {
	output = &ec2.DescribeSubnetsOutput{}
	if err := _m.recorder.CheckError("DescribeSubnets"); err != nil {
		return output, err
	}
	_m.recorder.Record("DescribeSubnets")
	returns, exist := _m.recorder.giveRecordedOutput("DescribeSubnets", _a0)
	if exist {

		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.DescribeSubnetsOutput), assertedErr
	}
	filteredSubnets := []*ec2.Subnet{}
	for _, val := range _a0.SubnetIds {
		for _, associatedsubnet := range _m.vpcassocaiatedsubnet {
			for _, subnet := range associatedsubnet {
				if *val == *subnet.SubnetId {
					filteredSubnets = append(filteredSubnets, subnet)
				}
			}
		}
	}

	if len(filteredSubnets) == 0 {
		for _, associatedsubnet := range _m.vpcassocaiatedsubnet {
			for _, subnet := range associatedsubnet {
				filteredSubnets = append(filteredSubnets, subnet)
			}
		}
	}
	furtherFilteredSubnet := []*ec2.Subnet{}
	for _, val := range filteredSubnets {
		for _, filter := range _a0.Filters {
			if *filter.Name == "vpc-id" {
				for _, vpcid := range filter.Values {
					if *val.VpcId == *vpcid {
						furtherFilteredSubnet = append(furtherFilteredSubnet, val)
					}
				}
			}
		}
	}

	if len(furtherFilteredSubnet) != 0 {
		filteredSubnets = furtherFilteredSubnet
		furtherFilteredSubnet = []*ec2.Subnet{}
	} else {
		furtherFilteredSubnet = filteredSubnets
	}
	for _, val := range filteredSubnets {
		for _, filter := range _a0.Filters {
			if *filter.Name == "availabilityZone" {
				for _, availabilityZone := range filter.Values {
					if *val.AvailabilityZone == *availabilityZone {
						furtherFilteredSubnet = append(furtherFilteredSubnet, val)
					}
				}
			}
		}
	}

	if len(furtherFilteredSubnet) != 0 {
		filteredSubnets = furtherFilteredSubnet
		furtherFilteredSubnet = []*ec2.Subnet{}
	} else {
		furtherFilteredSubnet = filteredSubnets
	}

	for _, val := range filteredSubnets {
		for _, filter := range _a0.Filters {
			if *filter.Name == "cidrBlock" {
				for _, cidrBlock := range filter.Values {
					if *val.CidrBlock == *cidrBlock {
						furtherFilteredSubnet = append(furtherFilteredSubnet, val)
					}
				}
			}
		}
	}
	if len(furtherFilteredSubnet) == 0 {
		furtherFilteredSubnet = filteredSubnets
	}

	output.Subnets = furtherFilteredSubnet
	return
}

// CreateNetworkInterface provides a mock function with given fields: _a0
func (_m *EC2API) CreateNetworkInterface(_a0 *ec2.CreateNetworkInterfaceInput) (output *ec2.CreateNetworkInterfaceOutput, err error) {
	output = &ec2.CreateNetworkInterfaceOutput{}
	if err := _m.recorder.CheckError("CreateNetworkInterface"); err != nil {
		return output, err
	}
	_m.recorder.Record("CreateNetworkInterface")
	returns, exist := _m.recorder.giveRecordedOutput("CreateNetworkInterface", _a0)
	if exist {

		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.CreateNetworkInterfaceOutput), assertedErr
	}
	subnet := _m.subnets[*_a0.SubnetId]
	cidr := subnet.CidrBlock
	var hostForCidr string
	// TODO: @sch00lb0y retry block is repeated many time, can be moved to a function
	// retry until you find the unassigned ip
	for {

		hostForCidr, err = PickRandomHostFromCIDR(*cidr)
		if err != nil {
			return
		}
		assignedIps, ok := _m.assignedIpOnSubnet[*_a0.SubnetId]
		if !ok {
			_m.assignedIpOnSubnet[*_a0.SubnetId] = append(_m.assignedIpOnSubnet[*_a0.SubnetId], hostForCidr)
			break
		}
		// check the random ip is alredy assiggned or not, if assingned, redo the step
		exist, _ := in_array(hostForCidr, assignedIps)
		if !exist {
			break
		}
	}
	var ntwInterfaceId string
	// retry until you find the unassinged interface id
	for {
		ntwInterfaceId = "eni-" + rangeIn(1000, 9999)
		_, exist := _m.networkinterfaces[ntwInterfaceId]
		if !exist {
			break
		}
	}

	// retry until you find the unassinged mac address
	var randomMac string
	for {
		randomMac, err = GiveRandMacAddress()
		if err != nil {
			return
		}
		exist, _ := in_array(randomMac, _m.assignedMacAddress)
		if !exist {
			_m.assignedMacAddress = append(_m.assignedMacAddress, randomMac)
			break
		}
	}
	primary := true
	privateDnsName := "ip-" + strings.Replace(hostForCidr, ".", "-", -1) + ".ap-southeast-1.compute.internal"
	ntwInterface := &ec2.NetworkInterface{
		Description:        _a0.Description,
		SubnetId:           _a0.SubnetId,
		VpcId:              subnet.VpcId,
		NetworkInterfaceId: &ntwInterfaceId,
		MacAddress:         &randomMac,
		PrivateIpAddress:   &hostForCidr,
		PrivateDnsName:     &privateDnsName,
		PrivateIpAddresses: []*ec2.NetworkInterfacePrivateIpAddress{
			&ec2.NetworkInterfacePrivateIpAddress{
				PrivateIpAddress: &hostForCidr,
				PrivateDnsName:   &privateDnsName,
				Primary:          &primary,
			},
		},
	}
	_m.networkinterfaces[ntwInterfaceId] = ntwInterface
	output.NetworkInterface = ntwInterface
	return
}

// DeleteNetworkInterface provides a mock function with given fields: _a0
func (_m *EC2API) DeleteNetworkInterface(_a0 *ec2.DeleteNetworkInterfaceInput) (output *ec2.DeleteNetworkInterfaceOutput, err error) {
	output = &ec2.DeleteNetworkInterfaceOutput{}
	if err := _m.recorder.CheckError("DeleteNetworkInterface"); err != nil {
		return output, err
	}
	_m.recorder.Record("DeleteNetworkInterface")
	returns, exist := _m.recorder.giveRecordedOutput("DeleteNetworkInterface", _a0)
	if exist {

		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.DeleteNetworkInterfaceOutput), assertedErr
	}
	_, ok := _m.networkinterfaces[*_a0.NetworkInterfaceId]
	if !ok {
		return nil, errors.New("networks interface not found")
	}
	delete(_m.networkinterfaces, *_a0.NetworkInterfaceId)
	return
}

// AllocateAddress provides a mock function with given fields: _a0
func (_m *EC2API) AllocateAddress(_a0 *ec2.AllocateAddressInput) (output *ec2.AllocateAddressOutput, err error) {
	output = &ec2.AllocateAddressOutput{}
	if err := _m.recorder.CheckError("AllocateAddress"); err != nil {
		return output, err
	}
	_m.recorder.Record("AllocateAddress")
	returns, exist := _m.recorder.giveRecordedOutput("AllocateAddress", _a0)
	if exist {
		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.AllocateAddressOutput), assertedErr
	}
	allocationId := uuid.New()
	allocationIdStr := "eipalloc-" + allocationId.String()

	// no need to retry since uuid is unique
	var allocatedElasticIps []string
	for _, allocatedIp := range _m.assignedelasticIps {
		allocatedElasticIps = append(allocatedElasticIps, allocatedIp)
	}
	var randomElasticIp string
	// retry to find a unassinged ip
	for {
		randomElasticIp = randomdata.IpV4Address()
		exist, _ := in_array(randomElasticIp, allocatedElasticIps)
		if !exist {
			break
		}
	}
	_m.assignedelasticIps[allocationIdStr] = randomElasticIp
	output.PublicIp = &randomElasticIp
	// default vpc is used, cuz in avi only vpc is used
	// TODO: add support for standard, if needed in future
	output.Domain = &AVI_STANDARD_ELASTIC_ALLOCATION_DOMAIN
	output.AllocationId = &allocationIdStr
	return
}

// ReleaseAddress provides a mock function with given fields: _a0
func (_m *EC2API) ReleaseAddress(_a0 *ec2.ReleaseAddressInput) (output *ec2.ReleaseAddressOutput, err error) {
	output = &ec2.ReleaseAddressOutput{}
	if err := _m.recorder.CheckError("ReleaseAddress"); err != nil {
		return output, err
	}
	_m.recorder.Record("ReleaseAddress")
	returns, exist := _m.recorder.giveRecordedOutput("ReleaseAddress", _a0)
	if exist {
		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.ReleaseAddressOutput), assertedErr
	}
	_, ok := _m.assignedelasticIps[*_a0.AllocationId]
	if !ok {
		err = errors.New("allocation id not exist")
		return
	}
	delete(_m.assignedelasticIps, *_a0.AllocationId)
	return
}

// CreateSecurityGroup provides a mock function with given fields: _a0
func (_m *EC2API) CreateSecurityGroup(_a0 *ec2.CreateSecurityGroupInput) (output *ec2.CreateSecurityGroupOutput, err error) {
	output = &ec2.CreateSecurityGroupOutput{}
	if err := _m.recorder.CheckError("CreateSecurityGroup"); err != nil {
		return output, err
	}
	_m.recorder.Record("CreateSecurityGroup")
	returns, exist := _m.recorder.giveRecordedOutput("CreateSecurityGroup", _a0)
	if exist {
		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.CreateSecurityGroupOutput), assertedErr
	}
	securityGroupId := uuid.New()
	securityGroupIdStr := "sg-" + securityGroupId.String()

	_m.assignedsecurityGroups[securityGroupIdStr] = &ec2.SecurityGroup{
		GroupId:     &securityGroupIdStr,
		VpcId:       _a0.VpcId,
		GroupName:   _a0.GroupName,
		Description: _a0.Description,
	}
	output.GroupId = &securityGroupIdStr
	return
}

// DeleteSecurityGroup provides a mock function with given fields: _a0
func (_m *EC2API) DeleteSecurityGroup(_a0 *ec2.DeleteSecurityGroupInput) (output *ec2.DeleteSecurityGroupOutput, err error) {
	output = &ec2.DeleteSecurityGroupOutput{}
	if err := _m.recorder.CheckError("DeleteSecurityGroup"); err != nil {
		return output, err
	}
	_m.recorder.Record("DeleteSecurityGroup")
	returns, exist := _m.recorder.giveRecordedOutput("DeleteSecurityGroup", _a0)
	if exist {
		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.DeleteSecurityGroupOutput), assertedErr
	}
	_, exist = _m.assignedsecurityGroups[*_a0.GroupId]
	if !exist {
		err = errors.New("group id not exist")
		return
	}
	delete(_m.assignedsecurityGroups, *_a0.GroupId)
	return
}

// DescribeSecurityGroups provides a mock function with given fields: _a0
func (_m *EC2API) DescribeSecurityGroups(_a0 *ec2.DescribeSecurityGroupsInput) (output *ec2.DescribeSecurityGroupsOutput, err error) {
	// TODO @sch00lb0y check what all the filters are being used in avi and implement according to that
	// for referenece check DescribeSubnets mock
	output = &ec2.DescribeSecurityGroupsOutput{}
	if err := _m.recorder.CheckError("DescribeSecurityGroups"); err != nil {
		return output, err
	}
	_m.recorder.Record("DescribeSecurityGroups")
	returns, exist := _m.recorder.giveRecordedOutput("DescribeSecurityGroups", _a0)
	if exist {
		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.DescribeSecurityGroupsOutput), assertedErr
	}

	filteredSecuirytGroup := []*ec2.SecurityGroup{}
	for _, groupId := range _a0.GroupIds {
		sg, ok := _m.assignedsecurityGroups[*groupId]
		if ok {
			filteredSecuirytGroup = append(filteredSecuirytGroup, sg)
		}
	}
	if len(_a0.Filters) == 0 {
		output.SecurityGroups = filteredSecuirytGroup
		return
	}

	if len(filteredSecuirytGroup) == 0 {
		for _, val := range _m.assignedsecurityGroups {
			filteredSecuirytGroup = append(filteredSecuirytGroup, val)
		}
	}
	furtherFilteredSecurityGroup := []*ec2.SecurityGroup{}
	for _, val := range filteredSecuirytGroup {
		for _, filter := range _a0.Filters {
			if *filter.Name == "vpc-id" {
				for _, vpcId := range filter.Values {
					if *val.VpcId == *vpcId {
						furtherFilteredSecurityGroup = append(furtherFilteredSecurityGroup, val)
					}
				}
			}
		}
	}

	output.SecurityGroups = furtherFilteredSecurityGroup
	return
}

// AuthorizeSecurityGroupIngress provides a mock function with given fields: _a0
func (_m *EC2API) AuthorizeSecurityGroupIngress(_a0 *ec2.AuthorizeSecurityGroupIngressInput) (output *ec2.AuthorizeSecurityGroupIngressOutput, err error) {
	output = &ec2.AuthorizeSecurityGroupIngressOutput{}
	if err := _m.recorder.CheckError("AuthorizeSecurityGroupIngress"); err != nil {
		return output, err
	}
	_m.recorder.Record("AuthorizeSecurityGroupIngress")
	returns, exist := _m.recorder.giveRecordedOutput("AuthorizeSecurityGroupIngress", _a0)
	if exist {
		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.AuthorizeSecurityGroupIngressOutput), assertedErr
	}
	securityGroup, exist := _m.assignedsecurityGroups[*_a0.GroupId]
	if !exist {
		err = errors.New("Group ID not exist")
	}

	ingressRule := &ec2.IpPermission{
		IpProtocol: _a0.IpProtocol,
		FromPort:   _a0.FromPort,
		ToPort:     _a0.ToPort,
		IpRanges: []*ec2.IpRange{
			&ec2.IpRange{
				CidrIp: _a0.CidrIp,
			},
		},
	}
	if len(securityGroup.IpPermissions) == 0 {
		securityGroup.IpPermissions = make([]*ec2.IpPermission, 0)
	}
	securityGroup.IpPermissions = append(securityGroup.IpPermissions, ingressRule)
	_m.assignedsecurityGroups[*_a0.GroupId] = securityGroup
	return
}

// RevokeSecurityGroupIngress provides a mock function with given fields: _a0
func (_m *EC2API) RevokeSecurityGroupIngress(_a0 *ec2.RevokeSecurityGroupIngressInput) (output *ec2.RevokeSecurityGroupIngressOutput, err error) {
	output = &ec2.RevokeSecurityGroupIngressOutput{}
	if err := _m.recorder.CheckError("RevokeSecurityGroupIngress"); err != nil {
		return output, err
	}
	_m.recorder.Record("RevokeSecurityGroupIngress")
	returns, exist := _m.recorder.giveRecordedOutput("RevokeSecurityGroupIngress", _a0)
	if exist {
		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.RevokeSecurityGroupIngressOutput), assertedErr
	}
	securityGroup, exist := _m.assignedsecurityGroups[*_a0.GroupId]
	if !exist {
		err = errors.New("Group ID not exist")
	}
	var matchingForAll bool
	var foundIndex int
	for index, ingressRule := range securityGroup.IpPermissions {
		matchingForAll = false
		if ingressRule.IpProtocol != _a0.IpProtocol || ingressRule.FromPort != _a0.FromPort || ingressRule.ToPort != _a0.ToPort {
			matchingForAll = true
			foundIndex = index
			break
		}
	}
	if matchingForAll {
		securityGroup.IpPermissions = append(securityGroup.IpPermissions[:foundIndex], securityGroup.IpPermissions[foundIndex+1:]...)
	}
	_m.assignedsecurityGroups[*_a0.GroupId] = securityGroup
	return
}

// AssignPrivateIpAddresses provides a mock function with given fields: _a0
func (_m *EC2API) AssignPrivateIpAddresses(_a0 *ec2.AssignPrivateIpAddressesInput) (output *ec2.AssignPrivateIpAddressesOutput, err error) {
	output = &ec2.AssignPrivateIpAddressesOutput{}
	if err := _m.recorder.CheckError("AssignPrivateIpAddresses"); err != nil {
		return output, err
	}
	_m.recorder.Record("AssignPrivateIpAddresses")
	returns, exist := _m.recorder.giveRecordedOutput("AssignPrivateIpAddresses", _a0)
	if exist {
		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.AssignPrivateIpAddressesOutput), assertedErr
	}
	networkInterface, exist := _m.networkinterfaces[*_a0.NetworkInterfaceId]
	if !exist {
		err = errors.New("interface id not found")
		return
	}
	primary := false
	if _a0.SecondaryPrivateIpAddressCount == nil {
		//handle for attaching ip
		for _, ip := range _a0.PrivateIpAddresses {
			if networkInterface.PrivateIpAddresses == nil {
				networkInterface.PrivateIpAddresses = make([]*ec2.NetworkInterfacePrivateIpAddress, 0)
			}
			privateDnsName := "ip-" + strings.Replace(*ip, ".", "-", -1) + ".ap-southeast-1.compute.internal"
			networkInterface.PrivateIpAddresses = append(networkInterface.PrivateIpAddresses, &ec2.NetworkInterfacePrivateIpAddress{
				PrivateIpAddress: ip,
				PrivateDnsName:   &privateDnsName,
				Primary:          &primary,
			})
		}

		_m.networkinterfaces[*_a0.NetworkInterfaceId] = networkInterface
		return
	}
	count := *_a0.SecondaryPrivateIpAddressCount

	subnet := _m.subnets[*networkInterface.SubnetId]
	cidr := subnet.CidrBlock
	randomSecondaryIps := []string{}
	var i int64
	for i = 0; i < count; i++ {
		var hostForCidr string

		for {
			hostForCidr, err = PickRandomHostFromCIDR(*cidr)
			if err != nil {
				return
			}
			assignedIps, ok := _m.assignedIpOnSubnet[*subnet.SubnetId]
			if !ok {
				_m.assignedIpOnSubnet[*subnet.SubnetId] = append(_m.assignedIpOnSubnet[*subnet.SubnetId], hostForCidr)
				break
			}
			// check the random ip is alredy assiggned or not, if assingned, redo the step
			exist, _ := in_array(hostForCidr, assignedIps)
			if !exist {
				randomSecondaryIps = append(randomSecondaryIps, hostForCidr)
				_m.assignedIpOnSubnet[*subnet.SubnetId] = append(_m.assignedIpOnSubnet[*subnet.SubnetId], hostForCidr)
				break
			}
			//time.Sleep(10 * time.Nanosecond)
		}
	}
	for _, secondaryip := range randomSecondaryIps {
		copyedIp := secondaryip
		privateDnsName := "ip-" + strings.Replace(secondaryip, ".", "-", -1) + ".ap-southeast-1.compute.internal"
		privateIP := &ec2.NetworkInterfacePrivateIpAddress{
			PrivateIpAddress: &copyedIp,
			PrivateDnsName:   &privateDnsName,
			Primary:          &primary,
		}
		networkInterface.PrivateIpAddresses = append(networkInterface.PrivateIpAddresses, privateIP)
	}
	_m.networkinterfaces[*_a0.NetworkInterfaceId] = networkInterface
	return
}

// UnassignPrivateIpAddresses provides a mock function with given fields: _a0
func (_m *EC2API) UnassignPrivateIpAddresses(_a0 *ec2.UnassignPrivateIpAddressesInput) (output *ec2.UnassignPrivateIpAddressesOutput, err error) {
	output = &ec2.UnassignPrivateIpAddressesOutput{}
	if err := _m.recorder.CheckError("UnassignPrivateIpAddresses"); err != nil {
		return output, err
	}
	_m.recorder.Record("UnassignPrivateIpAddresses")
	returns, exist := _m.recorder.giveRecordedOutput("UnassignPrivateIpAddresses", _a0)
	if exist {
		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.UnassignPrivateIpAddressesOutput), assertedErr
	}
	networkInterface, exist := _m.networkinterfaces[*_a0.NetworkInterfaceId]
	if !exist {
		err = errors.New("interface id not found")
	}
	var foundIndex int
	var found bool
	for _, incommingPrivateIp := range _a0.PrivateIpAddresses {
		for index, privateIp := range networkInterface.PrivateIpAddresses {
			found = false
			if privateIp.PrivateIpAddress == incommingPrivateIp {
				foundIndex = index
				found = true
				break
			}
			if found {
				networkInterface.PrivateIpAddresses = append(networkInterface.PrivateIpAddresses[:foundIndex], networkInterface.PrivateIpAddresses[foundIndex+1:]...)
			}
		}
	}
	return
}

// DescribeInstances provides a mock function with given fields: _a0
func (_m *EC2API) DescribeInstances(_a0 *ec2.DescribeInstancesInput) (output *ec2.DescribeInstancesOutput, err error) {
	output = &ec2.DescribeInstancesOutput{}
	if err := _m.recorder.CheckError("DescribeInstances"); err != nil {
		return output, err
	}
	_m.recorder.Record("DescribeInstances")
	returns, exist := _m.recorder.giveRecordedOutput("DescribeInstances", _a0)
	if exist {
		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.DescribeInstancesOutput), assertedErr
	}
	filteredInstances := []*ec2.Instance{}
	for _, instanceId := range _a0.InstanceIds {
		for _, instance := range _m.createdEc2instances {
			if *instance.InstanceId == *instanceId {
				filteredInstances = append(filteredInstances, instance)
			}
		}
	}
	if len(_a0.Filters) == 0 {
		reservations := []*ec2.Reservation{
			&ec2.Reservation{
				Instances: filteredInstances,
			},
		}
		output.Reservations = reservations
		return
	}
	if len(filteredInstances) == 0 {
		for _, val := range _m.createdEc2instances {
			filteredInstances = append(filteredInstances, val)
		}
	}
	furtherFilteredInstances := []*ec2.Instance{}
	for _, val := range filteredInstances {
		for _, filter := range _a0.Filters {
			if *filter.Name == "vpc-id" {
				for _, vpcId := range filter.Values {
					if *val.VpcId == *vpcId {
						furtherFilteredInstances = append(furtherFilteredInstances, val)
					}
				}
			}
		}
	}
	if len(furtherFilteredInstances) != 0 {
		filteredInstances = furtherFilteredInstances
		furtherFilteredInstances = []*ec2.Instance{}
	} else {
		furtherFilteredInstances = filteredInstances
	}

	for _, val := range filteredInstances {
		for _, filter := range _a0.Filters {
			if *filter.Name == "network-interface.subnet-id" {
				for _, subnetId := range filter.Values {
					if *val.NetworkInterfaces[0].SubnetId == *subnetId {
						furtherFilteredInstances = append(furtherFilteredInstances, val)
					}
				}
			}
		}
	}
	if len(furtherFilteredInstances) == 0 {
		furtherFilteredInstances = filteredInstances
	}
	reservations := []*ec2.Reservation{
		&ec2.Reservation{
			Instances: furtherFilteredInstances,
		},
	}
	output.Reservations = reservations
	return
}

// DescribeInstanceAttribute provides a mock function with given fields: _a0
func (_m *EC2API) DescribeInstanceAttribute(_a0 *ec2.DescribeInstanceAttributeInput) (output *ec2.DescribeInstanceAttributeOutput, err error) {
	output = &ec2.DescribeInstanceAttributeOutput{}
	if err := _m.recorder.CheckError("DescribeInstanceAttribute"); err != nil {
		return output, err
	}
	_m.recorder.Record("DescribeInstanceAttribute")
	returns, exist := _m.recorder.giveRecordedOutput("DescribeInstanceAttribute", _a0)
	if exist {
		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.DescribeInstanceAttributeOutput), assertedErr
	}
	//NOTE: support for GroupSet only added, add remaining attribute if needed.
	var groupSet string = "groupSet"
	if _a0.Attribute == &groupSet {
		for _, instance := range _m.createdEc2instances {
			if instance.InstanceId == _a0.InstanceId {
				output.Groups = instance.SecurityGroups
			}
		}
	}
	return
}

func (_m *EC2API) CreateTags(_a0 *ec2.CreateTagsInput) (output *ec2.CreateTagsOutput, err error) {
	output = &ec2.CreateTagsOutput{}
	if err := _m.recorder.CheckError("CreateTags"); err != nil {
		return output, err
	}
	_m.recorder.Record("CreateTags")
	returns, exist := _m.recorder.giveRecordedOutput("CreateTags", _a0)
	if exist {
		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.CreateTagsOutput), assertedErr
	}
	//if prefix is eni then update network interface tag
	for _, resourceId := range _a0.Resources {
		if strings.HasPrefix(*resourceId, "eni") {
			// update tag for network interface
			networkInterfaceCard, ok := _m.networkinterfaces[*resourceId]
			if !ok {
				return output, errors.New("network interface not found")
			}
			networkInterfaceCard.TagSet = _a0.Tags
			_m.networkinterfaces[*resourceId] = networkInterfaceCard
		}
	}
	return
}

// DescribeNetworkInterfaces provides a mock function with given fields: _a0
func (_m *EC2API) DescribeNetworkInterfaces(_a0 *ec2.DescribeNetworkInterfacesInput) (output *ec2.DescribeNetworkInterfacesOutput, err error) {
	output = &ec2.DescribeNetworkInterfacesOutput{}
	if err := _m.recorder.CheckError("DescribeNetworkInterfaces"); err != nil {
		return output, err
	}
	_m.recorder.Record("DescribeNetworkInterfaces")
	returns, exist := _m.recorder.giveRecordedOutput("DescribeNetworkInterfaces", _a0)
	if exist {
		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.DescribeNetworkInterfacesOutput), assertedErr
	}

	filteredNetworkInterfaces := []*ec2.NetworkInterface{}
	for _, id := range _a0.NetworkInterfaceIds {
		val, ok := _m.networkinterfaces[*id]
		if ok {
			filteredNetworkInterfaces = append(filteredNetworkInterfaces, val)
		}
	}
	if len(_a0.Filters) == 0 {
		output.NetworkInterfaces = filteredNetworkInterfaces
		return
	}

	if len(filteredNetworkInterfaces) == 0 {
		for _, val := range _m.networkinterfaces {
			filteredNetworkInterfaces = append(filteredNetworkInterfaces, val)
		}
	}

	furtherFilteredNetworkInterface := []*ec2.NetworkInterface{}

	for _, val := range filteredNetworkInterfaces {
		for _, filter := range _a0.Filters {
			if *filter.Name == "vpc-id" {
				for _, vpcid := range filter.Values {
					if *val.VpcId == *vpcid {
						furtherFilteredNetworkInterface = append(furtherFilteredNetworkInterface, val)
					}
				}
			}
		}
	}

	if len(furtherFilteredNetworkInterface) != 0 {
		filteredNetworkInterfaces = furtherFilteredNetworkInterface
		furtherFilteredNetworkInterface = []*ec2.NetworkInterface{}
	} else {
		furtherFilteredNetworkInterface = filteredNetworkInterfaces
	}

	for _, val := range filteredNetworkInterfaces {
		for _, filter := range _a0.Filters {
			if *filter.Name == "subnet-id" {
				for _, subnetid := range filter.Values {
					if *val.SubnetId == *subnetid {
						furtherFilteredNetworkInterface = append(furtherFilteredNetworkInterface, val)
					}
				}
			}
		}
	}
	if len(furtherFilteredNetworkInterface) != 0 {
		filteredNetworkInterfaces = furtherFilteredNetworkInterface
		furtherFilteredNetworkInterface = []*ec2.NetworkInterface{}
	} else {
		furtherFilteredNetworkInterface = filteredNetworkInterfaces
	}

	for _, val := range filteredNetworkInterfaces {
		for _, filter := range _a0.Filters {
			if *filter.Name == "availabilityZone" {
				for _, availabilityZone := range filter.Values {
					if *val.AvailabilityZone == *availabilityZone {
						furtherFilteredNetworkInterface = append(furtherFilteredNetworkInterface, val)
					}
				}
			}
		}
	}

	if len(furtherFilteredNetworkInterface) != 0 {
		filteredNetworkInterfaces = furtherFilteredNetworkInterface
		furtherFilteredNetworkInterface = []*ec2.NetworkInterface{}
	} else {
		furtherFilteredNetworkInterface = filteredNetworkInterfaces
	}

	for _, val := range filteredNetworkInterfaces {
		for _, filter := range _a0.Filters {
			if *filter.Name == "availabilityZone" {
				for _, availabilityZone := range filter.Values {
					if *val.AvailabilityZone == *availabilityZone {
						furtherFilteredNetworkInterface = append(furtherFilteredNetworkInterface, val)
					}
				}
			}
		}
	}
	if len(furtherFilteredNetworkInterface) != 0 {
		filteredNetworkInterfaces = furtherFilteredNetworkInterface
		furtherFilteredNetworkInterface = []*ec2.NetworkInterface{}
	} else {
		furtherFilteredNetworkInterface = filteredNetworkInterfaces
	}

	for _, val := range filteredNetworkInterfaces {
		for _, filter := range _a0.Filters {
			if *filter.Name == "mac-address" {
				for _, macAddress := range filter.Values {
					if *val.MacAddress == *macAddress {
						furtherFilteredNetworkInterface = append(furtherFilteredNetworkInterface, val)
					}
				}
			}
		}
	}
	if len(furtherFilteredNetworkInterface) != 0 {
		filteredNetworkInterfaces = furtherFilteredNetworkInterface
		furtherFilteredNetworkInterface = []*ec2.NetworkInterface{}
	} else {
		furtherFilteredNetworkInterface = filteredNetworkInterfaces
	}

	for _, val := range filteredNetworkInterfaces {
		for _, filter := range _a0.Filters {
			if strings.HasPrefix("tag", *filter.Name) {
				// get the tag name
				tagName := strings.Split(*filter.Name, ":")[1]
				tagValue := *filter.Values[0]
				for _, tag := range val.TagSet {
					if *tag.Key == tagName {
						if *tag.Value == tagValue {
							furtherFilteredNetworkInterface = append(furtherFilteredNetworkInterface, val)
						}
					}
				}
			}
		}
	}
	if len(furtherFilteredNetworkInterface) == 0 {
		furtherFilteredNetworkInterface = filteredNetworkInterfaces
	}

	output.NetworkInterfaces = furtherFilteredNetworkInterface
	return
}

// AssociateAddress provides a mock function with given fields: _a0
func (_m *EC2API) AssociateAddress(_a0 *ec2.AssociateAddressInput) (output *ec2.AssociateAddressOutput, err error) {
	output = &ec2.AssociateAddressOutput{}
	if err := _m.recorder.CheckError("AssociateAddress"); err != nil {
		return output, err
	}
	_m.recorder.Record("AssociateAddress")
	returns, exist := _m.recorder.giveRecordedOutput("AssociateAddress", _a0)
	if exist {
		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.AssociateAddressOutput), assertedErr
	}
	networkInterfaceCard, ok := _m.networkinterfaces[*_a0.NetworkInterfaceId]
	if !ok {
		return output, errors.New("network interface not found")
	}
	for i, privateIP := range networkInterfaceCard.PrivateIpAddresses {
		if *privateIP.PrivateIpAddress == *_a0.PrivateIpAddress {
			association := &ec2.NetworkInterfaceAssociation{}
			association.AllocationId = _a0.AllocationId
			association.PublicIp = _a0.PublicIp
			associationId := uuid.New()

			associationIdStr := "fip-alloc-" + associationId.String()
			association.AssociationId = &associationIdStr
			privateIP.Association = association
			networkInterfaceCard.PrivateIpAddresses[i] = privateIP
		}
	}
	return
}

// DescribeAddresses provides a mock function with given fields: _a0
func (_m *EC2API) DescribeAddresses(_a0 *ec2.DescribeAddressesInput) (output *ec2.DescribeAddressesOutput, err error) {
	output = &ec2.DescribeAddressesOutput{}
	output.Addresses = make([]*ec2.Address, 0)
	if err := _m.recorder.CheckError("DescribeAddresses"); err != nil {
		return output, err
	}
	_m.recorder.Record("DescribeAddresses")
	returns, exist := _m.recorder.giveRecordedOutput("DescribeAddresses", _a0)
	if exist {
		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.DescribeAddressesOutput), assertedErr
	}
	for _, inputIP := range _a0.PublicIps {
		for allocationId, elasticIP := range _m.assignedelasticIps {
			if elasticIP == *inputIP {
				output.Addresses = append(output.Addresses, &ec2.Address{
					AllocationId: &allocationId,
					PublicIp:     inputIP,
				})
			}
		}
	}
	return
}

// DisassociateAddress provides a mock function with given fields: _a0
func (_m *EC2API) DisassociateAddress(_a0 *ec2.DisassociateAddressInput) (output *ec2.DisassociateAddressOutput, err error) {
	output = &ec2.DisassociateAddressOutput{}
	if err := _m.recorder.CheckError("AssociateAddress"); err != nil {
		return output, err
	}
	_m.recorder.Record("AssociateAddress")
	returns, exist := _m.recorder.giveRecordedOutput("AssociateAddress", _a0)
	if exist {
		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.DisassociateAddressOutput), assertedErr
	}
	for networkInterfaceIndex, networkInterfaceCard := range _m.networkinterfaces {
		for i, privateIP := range networkInterfaceCard.PrivateIpAddresses {
			if *privateIP.Association.AllocationId == *_a0.AssociationId {
				networkInterfaceCard.PrivateIpAddresses[i].Association = &ec2.NetworkInterfaceAssociation{}
				_m.networkinterfaces[networkInterfaceIndex] = networkInterfaceCard
			}
		}
	}
	return
}

// DescribeRouteTables provides a mock function with given fields: _a0
func (_m *EC2API) DescribeRouteTables(_a0 *ec2.DescribeRouteTablesInput) (output *ec2.DescribeRouteTablesOutput, err error) {
	output = &ec2.DescribeRouteTablesOutput{}
	if err := _m.recorder.CheckError("DescribeRouteTables"); err != nil {
		return output, err
	}
	_m.recorder.Record("DescribeRouteTables")
	returns, exist := _m.recorder.giveRecordedOutput("DescribeRouteTables", _a0)
	if exist {
		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.DescribeRouteTablesOutput), assertedErr
	}

	filteredRouteTables := []*ec2.RouteTable{}
	for _, filterId := range _a0.RouteTableIds {
		for routeTableID, routeTable := range _m.routeTable {
			if routeTableID == *filterId {
				filteredRouteTables = append(filteredRouteTables, routeTable)
			}
		}
	}
	if len(_a0.Filters) == 0 {
		output.RouteTables = filteredRouteTables
		return
	}

	if len(filteredRouteTables) == 0 {
		for _, val := range _m.routeTable {
			filteredRouteTables = append(filteredRouteTables, val)
		}
	}

	furtherFilteredRouteTables := []*ec2.RouteTable{}

	for _, val := range filteredRouteTables {
		for _, filter := range _a0.Filters {
			if *filter.Name == "vpc-id" {
				for _, vpcId := range filter.Values {
					if *val.VpcId == *vpcId {
						furtherFilteredRouteTables = append(furtherFilteredRouteTables, val)
					}
				}
			}
		}
	}
	output.RouteTables = furtherFilteredRouteTables
	return
}

// DescribeAvailabilityZones provides a mock function with given fields: _a0
func (_m *EC2API) DescribeAvailabilityZones(_a0 *ec2.DescribeAvailabilityZonesInput) (output *ec2.DescribeAvailabilityZonesOutput, err error) {
	output = &ec2.DescribeAvailabilityZonesOutput{}
	if err := _m.recorder.CheckError("DescribeAvailabilityZones"); err != nil {
		return output, err
	}
	_m.recorder.Record("DescribeAvailabilityZones")
	returns, exist := _m.recorder.giveRecordedOutput("DescribeAvailabilityZones", _a0)
	if exist {
		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.DescribeAvailabilityZonesOutput), assertedErr
	}
	output.AvailabilityZones = []*ec2.AvailabilityZone{
		&ec2.AvailabilityZone{
			RegionName: &defaultAvailabilityZone,
			State:      proto.String("available"),
			ZoneName:   &defaultAvailabilityZone,
		},
	}
	return
}

// StopInstances provides a mock function with given fields: _a0
func (_m *EC2API) StopInstances(_a0 *ec2.StopInstancesInput) (output *ec2.StopInstancesOutput, err error) {
	output = &ec2.StopInstancesOutput{}
	if err := _m.recorder.CheckError("StopInstances"); err != nil {
		return output, err
	}
	_m.recorder.Record("StopInstances")
	returns, exist := _m.recorder.giveRecordedOutput("StopInstances", _a0)
	if exist {
		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.StopInstancesOutput), assertedErr
	}
	for _, instanceId := range _a0.InstanceIds {
		for _, instance := range _m.createdEc2instances {
			if *instance.InstanceId == *instanceId {
				instance.State.Code = proto.Int64(80)
				instance.State.Name = proto.String("stopped")
			}
		}
	}
	return
}

// StartInstances provides a mock function with given fields: _a0
func (_m *EC2API) StartInstances(_a0 *ec2.StartInstancesInput) (output *ec2.StartInstancesOutput, err error) {
	output = &ec2.StartInstancesOutput{}
	if err := _m.recorder.CheckError("StartInstances"); err != nil {
		return output, err
	}
	_m.recorder.Record("StartInstances")
	returns, exist := _m.recorder.giveRecordedOutput("StartInstances", _a0)
	if exist {
		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.StartInstancesOutput), assertedErr
	}
	for _, instanceId := range _a0.InstanceIds {
		for _, instance := range _m.createdEc2instances {
			if *instance.InstanceId == *instanceId {
				instance.State.Code = proto.Int64(80)
				instance.State.Name = proto.String("stopped")
			}
		}
	}
	return
}

// RebootInstances provides a mock function with given fields: _a0
func (_m *EC2API) RebootInstances(_a0 *ec2.RebootInstancesInput) (output *ec2.RebootInstancesOutput, err error) {
	output = &ec2.RebootInstancesOutput{}
	if err := _m.recorder.CheckError("RebootInstances"); err != nil {
		return output, err
	}
	_m.recorder.Record("RebootInstances")
	returns, exist := _m.recorder.giveRecordedOutput("RebootInstances", _a0)
	if exist {
		assertedErr, _ := returns[1].(error)
		return returns[0].(*ec2.RebootInstancesOutput), assertedErr
	}
	for _, instanceId := range _a0.InstanceIds {
		for _, instance := range _m.createdEc2instances {
			if *instance.InstanceId == *instanceId {
				instance.State.Code = proto.Int64(80)
				instance.State.Name = proto.String("stopped")
			}
		}
	}
	return
}
